"""
Alpha Model Framework - Ported from QuantConnect LEAN.

Provides signal generation models that produce Insights (trading signals).

Original: https://github.com/QuantConnect/Lean/tree/master/Algorithm.Framework/Alphas
License: Apache 2.0
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
from typing import Dict, List, Optional, Any
import uuid

from backend.tradingbot.indicators import (
    ExponentialMovingAverage,
    RelativeStrengthIndex,
    MACD,
    RateOfChange,
)


class InsightDirection(Enum):
    """Direction of the trading insight."""
    UP = 1      # Expect price to increase
    DOWN = -1   # Expect price to decrease
    FLAT = 0    # Expect price to stay flat


class InsightType(Enum):
    """Type of insight being generated."""
    PRICE = "price"           # Price direction prediction
    VOLATILITY = "volatility" # Volatility prediction
    ALPHA = "alpha"           # Alpha/excess return prediction


@dataclass
class Insight:
    """
    Represents a trading signal generated by an Alpha Model.

    An Insight provides:
    - Direction: Expected price movement
    - Magnitude: Expected size of movement (optional)
    - Confidence: Confidence level in the prediction
    - Period: How long the insight is valid
    """
    symbol: str
    direction: InsightDirection
    generated_time: datetime = field(default_factory=datetime.now)
    close_time: Optional[datetime] = None
    period: timedelta = field(default_factory=lambda: timedelta(days=1))
    insight_type: InsightType = InsightType.PRICE
    magnitude: Optional[float] = None
    confidence: Optional[float] = None
    weight: float = 1.0
    source_model: str = ""
    id: str = field(default_factory=lambda: str(uuid.uuid4()))

    def __post_init__(self):
        if self.close_time is None:
            self.close_time = self.generated_time + self.period

    @property
    def is_active(self) -> bool:
        """Whether the insight is still valid."""
        return datetime.now() < self.close_time

    @property
    def is_expired(self) -> bool:
        """Whether the insight has expired."""
        return not self.is_active

    def __repr__(self) -> str:
        return (f"Insight({self.symbol}, {self.direction.name}, "
                f"conf={self.confidence or 'N/A'}, "
                f"mag={self.magnitude or 'N/A'})")

    @classmethod
    def price(cls, symbol: str, period: timedelta,
              direction: InsightDirection,
              magnitude: Optional[float] = None,
              confidence: Optional[float] = None,
              weight: float = 1.0,
              source_model: str = "") -> "Insight":
        """Factory method for price insights."""
        return cls(
            symbol=symbol,
            direction=direction,
            period=period,
            insight_type=InsightType.PRICE,
            magnitude=magnitude,
            confidence=confidence,
            weight=weight,
            source_model=source_model,
        )


class AlphaModel(ABC):
    """
    Abstract base class for Alpha Models.

    Alpha Models analyze market data and generate Insights (trading signals).
    They are the first component in the trading pipeline.
    """

    def __init__(self, name: Optional[str] = None):
        self._name = name or self.__class__.__name__

    @property
    def name(self) -> str:
        return self._name

    @abstractmethod
    def update(self, data: Dict[str, Any]) -> List[Insight]:
        """
        Generate insights based on new market data.

        Args:
            data: Dictionary of market data keyed by symbol

        Returns:
            List of Insights (trading signals)
        """
        pass

    def on_securities_changed(self, added: List[str], removed: List[str]) -> None:
        """
        Handle universe changes.

        Args:
            added: Symbols added to the universe
            removed: Symbols removed from the universe
        """
        pass

    def __repr__(self) -> str:
        return f"{self._name}"


class EmaCrossAlphaModel(AlphaModel):
    """
    EMA Crossover Alpha Model.

    Generates UP insight when fast EMA crosses above slow EMA.
    Generates DOWN insight when fast EMA crosses below slow EMA.

    Ported from LEAN's EmaCrossAlphaModel.cs
    """

    def __init__(self, fast_period: int = 12, slow_period: int = 26,
                 resolution: str = "daily", name: Optional[str] = None):
        name = name or f"EmaCrossAlpha({fast_period},{slow_period})"
        super().__init__(name)
        self._fast_period = fast_period
        self._slow_period = slow_period
        self._resolution = resolution
        self._prediction_interval = fast_period

        # Per-symbol data
        self._symbol_data: Dict[str, "_EmaSymbolData"] = {}

    def update(self, data: Dict[str, Any]) -> List[Insight]:
        """Generate insights from EMA crossovers."""
        insights = []

        for symbol, price_data in data.items():
            if symbol not in self._symbol_data:
                self._symbol_data[symbol] = _EmaSymbolData(
                    symbol, self._fast_period, self._slow_period
                )

            symbol_data = self._symbol_data[symbol]
            close_price = price_data.get("close", price_data.get("price", 0))

            if close_price <= 0:
                continue

            symbol_data.update(close_price)

            if not symbol_data.is_ready:
                continue

            # Check for crossover
            fast_is_over_slow = symbol_data.fast.value > symbol_data.slow.value

            if symbol_data.previous_fast_over_slow is not None:
                if fast_is_over_slow and not symbol_data.previous_fast_over_slow:
                    # Bullish crossover
                    insights.append(Insight.price(
                        symbol=symbol,
                        period=timedelta(days=self._prediction_interval),
                        direction=InsightDirection.UP,
                        source_model=self._name,
                    ))
                elif not fast_is_over_slow and symbol_data.previous_fast_over_slow:
                    # Bearish crossover
                    insights.append(Insight.price(
                        symbol=symbol,
                        period=timedelta(days=self._prediction_interval),
                        direction=InsightDirection.DOWN,
                        source_model=self._name,
                    ))

            symbol_data.previous_fast_over_slow = fast_is_over_slow

        return insights

    def on_securities_changed(self, added: List[str], removed: List[str]) -> None:
        for symbol in removed:
            if symbol in self._symbol_data:
                del self._symbol_data[symbol]


class _EmaSymbolData:
    """Per-symbol data for EMA cross model."""

    def __init__(self, symbol: str, fast_period: int, slow_period: int):
        self.symbol = symbol
        self.fast = ExponentialMovingAverage(fast_period)
        self.slow = ExponentialMovingAverage(slow_period)
        self.previous_fast_over_slow: Optional[bool] = None

    @property
    def is_ready(self) -> bool:
        return self.fast.is_ready and self.slow.is_ready

    def update(self, price: float) -> None:
        now = datetime.now()
        self.fast.update(now, price)
        self.slow.update(now, price)


class RsiAlphaModel(AlphaModel):
    """
    RSI Alpha Model.

    Generates insights based on RSI overbought/oversold levels.

    - UP when RSI crosses below oversold level (buy the dip)
    - DOWN when RSI crosses above overbought level (sell the rally)
    """

    def __init__(self, period: int = 14, oversold: float = 30,
                 overbought: float = 70, name: Optional[str] = None):
        name = name or f"RsiAlpha({period},{oversold},{overbought})"
        super().__init__(name)
        self._period = period
        self._oversold = oversold
        self._overbought = overbought

        self._indicators: Dict[str, RelativeStrengthIndex] = {}
        self._previous_rsi: Dict[str, float] = {}

    def update(self, data: Dict[str, Any]) -> List[Insight]:
        insights = []

        for symbol, price_data in data.items():
            if symbol not in self._indicators:
                self._indicators[symbol] = RelativeStrengthIndex(self._period)

            rsi = self._indicators[symbol]
            close_price = price_data.get("close", price_data.get("price", 0))

            if close_price <= 0:
                continue

            rsi.update(datetime.now(), close_price)

            if not rsi.is_ready:
                continue

            prev_rsi = self._previous_rsi.get(symbol)
            current_rsi = rsi.value

            if prev_rsi is not None:
                # Crossed into oversold
                if prev_rsi >= self._oversold and current_rsi < self._oversold:
                    insights.append(Insight.price(
                        symbol=symbol,
                        period=timedelta(days=self._period),
                        direction=InsightDirection.UP,
                        confidence=0.7,
                        source_model=self._name,
                    ))
                # Crossed into overbought
                elif prev_rsi <= self._overbought and current_rsi > self._overbought:
                    insights.append(Insight.price(
                        symbol=symbol,
                        period=timedelta(days=self._period),
                        direction=InsightDirection.DOWN,
                        confidence=0.7,
                        source_model=self._name,
                    ))

            self._previous_rsi[symbol] = current_rsi

        return insights


class MacdAlphaModel(AlphaModel):
    """
    MACD Alpha Model.

    Generates insights based on MACD line crossing signal line.

    - UP when MACD crosses above signal line
    - DOWN when MACD crosses below signal line
    """

    def __init__(self, fast_period: int = 12, slow_period: int = 26,
                 signal_period: int = 9, name: Optional[str] = None):
        name = name or f"MacdAlpha({fast_period},{slow_period},{signal_period})"
        super().__init__(name)
        self._fast_period = fast_period
        self._slow_period = slow_period
        self._signal_period = signal_period

        self._indicators: Dict[str, MACD] = {}
        self._previous_histogram: Dict[str, float] = {}

    def update(self, data: Dict[str, Any]) -> List[Insight]:
        insights = []

        for symbol, price_data in data.items():
            if symbol not in self._indicators:
                self._indicators[symbol] = MACD(
                    self._fast_period, self._slow_period, self._signal_period
                )

            macd = self._indicators[symbol]
            close_price = price_data.get("close", price_data.get("price", 0))

            if close_price <= 0:
                continue

            macd.update(datetime.now(), close_price)

            if not macd.is_ready:
                continue

            prev_hist = self._previous_histogram.get(symbol)
            current_hist = macd.histogram

            if prev_hist is not None:
                # Histogram crossed from negative to positive (bullish)
                if prev_hist < 0 and current_hist >= 0:
                    insights.append(Insight.price(
                        symbol=symbol,
                        period=timedelta(days=self._fast_period),
                        direction=InsightDirection.UP,
                        source_model=self._name,
                    ))
                # Histogram crossed from positive to negative (bearish)
                elif prev_hist > 0 and current_hist <= 0:
                    insights.append(Insight.price(
                        symbol=symbol,
                        period=timedelta(days=self._fast_period),
                        direction=InsightDirection.DOWN,
                        source_model=self._name,
                    ))

            self._previous_histogram[symbol] = current_hist

        return insights


class MomentumAlphaModel(AlphaModel):
    """
    Momentum Alpha Model.

    Generates insights based on rate of change (momentum).

    - UP when momentum is positive and above threshold
    - DOWN when momentum is negative and below threshold
    """

    def __init__(self, period: int = 14, threshold: float = 5.0,
                 name: Optional[str] = None):
        name = name or f"MomentumAlpha({period},{threshold})"
        super().__init__(name)
        self._period = period
        self._threshold = threshold

        self._indicators: Dict[str, RateOfChange] = {}

    def update(self, data: Dict[str, Any]) -> List[Insight]:
        insights = []

        for symbol, price_data in data.items():
            if symbol not in self._indicators:
                self._indicators[symbol] = RateOfChange(self._period)

            roc = self._indicators[symbol]
            close_price = price_data.get("close", price_data.get("price", 0))

            if close_price <= 0:
                continue

            roc.update(datetime.now(), close_price)

            if not roc.is_ready:
                continue

            if roc.value > self._threshold:
                insights.append(Insight.price(
                    symbol=symbol,
                    period=timedelta(days=self._period),
                    direction=InsightDirection.UP,
                    magnitude=roc.value / 100,  # Convert percentage
                    source_model=self._name,
                ))
            elif roc.value < -self._threshold:
                insights.append(Insight.price(
                    symbol=symbol,
                    period=timedelta(days=self._period),
                    direction=InsightDirection.DOWN,
                    magnitude=abs(roc.value) / 100,
                    source_model=self._name,
                ))

        return insights


class ConstantAlphaModel(AlphaModel):
    """
    Constant Alpha Model.

    Generates the same insight for all securities.
    Useful for buy-and-hold or always-short strategies.
    """

    def __init__(self, direction: InsightDirection = InsightDirection.UP,
                 period: timedelta = timedelta(days=1),
                 name: Optional[str] = None):
        name = name or f"ConstantAlpha({direction.name})"
        super().__init__(name)
        self._direction = direction
        self._period = period
        self._securities: List[str] = []

    def update(self, data: Dict[str, Any]) -> List[Insight]:
        insights = []
        for symbol in data.keys():
            insights.append(Insight.price(
                symbol=symbol,
                period=self._period,
                direction=self._direction,
                source_model=self._name,
            ))
        return insights

    def on_securities_changed(self, added: List[str], removed: List[str]) -> None:
        self._securities.extend(added)
        for symbol in removed:
            if symbol in self._securities:
                self._securities.remove(symbol)
