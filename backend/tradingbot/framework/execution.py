"""
Execution Models - Ported from QuantConnect LEAN.

Converts Portfolio Targets into actual orders with execution algorithms.

Original: https://github.com/QuantConnect/Lean/tree/master/Algorithm.Framework/Execution
License: Apache 2.0
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any
from enum import Enum
import uuid


class OrderType(Enum):
    """Order type enumeration."""
    MARKET = "market"
    LIMIT = "limit"
    STOP = "stop"
    STOP_LIMIT = "stop_limit"
    MARKET_ON_OPEN = "moo"
    MARKET_ON_CLOSE = "moc"


class OrderSide(Enum):
    """Order side enumeration."""
    BUY = "buy"
    SELL = "sell"


class TimeInForce(Enum):
    """Time in force for orders."""
    DAY = "day"
    GTC = "gtc"  # Good till canceled
    IOC = "ioc"  # Immediate or cancel
    FOK = "fok"  # Fill or kill
    GTD = "gtd"  # Good till date
    OPG = "opg"  # At the open
    CLS = "cls"  # At the close


@dataclass
class OrderTicket:
    """
    Represents an order to be submitted.

    Generated by Execution Models from Portfolio Targets.
    """
    symbol: str
    quantity: float
    order_type: OrderType = OrderType.MARKET
    side: OrderSide = OrderSide.BUY
    limit_price: Optional[float] = None
    stop_price: Optional[float] = None
    time_in_force: TimeInForce = TimeInForce.DAY
    tag: str = ""
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    created_time: datetime = field(default_factory=datetime.now)

    @property
    def is_buy(self) -> bool:
        return self.side == OrderSide.BUY

    @property
    def is_sell(self) -> bool:
        return self.side == OrderSide.SELL

    def __repr__(self) -> str:
        return (f"OrderTicket({self.side.name} {self.quantity:.2f} {self.symbol} "
                f"@ {self.order_type.name})")


@dataclass
class PortfolioTarget:
    """Portfolio target (imported from portfolio module)."""
    symbol: str
    quantity: float
    tag: str = ""


class ExecutionModel(ABC):
    """
    Abstract base class for Execution Models.

    Execution Models determine how to execute Portfolio Targets,
    handling order timing, sizing, and execution algorithms.
    """

    def __init__(self, name: Optional[str] = None):
        self._name = name or self.__class__.__name__

    @property
    def name(self) -> str:
        return self._name

    @abstractmethod
    def execute(self, targets: List[PortfolioTarget],
                current_holdings: Dict[str, float],
                current_prices: Dict[str, float],
                portfolio_value: float) -> List[OrderTicket]:
        """
        Generate orders from portfolio targets.

        Args:
            targets: List of portfolio targets
            current_holdings: Current holdings {symbol: quantity}
            current_prices: Current prices {symbol: price}
            portfolio_value: Total portfolio value

        Returns:
            List of OrderTickets to submit
        """
        pass

    def on_order_filled(self, symbol: str, quantity: float, price: float) -> None:
        """Handle order fill notification."""
        pass

    def __repr__(self) -> str:
        return f"{self._name}"


class ImmediateExecutionModel(ExecutionModel):
    """
    Immediate Execution Model.

    Sends market orders immediately to reach target positions.
    Simple and fast, but may have slippage on large orders.

    Ported from LEAN's ImmediateExecutionModel.cs
    """

    def __init__(self, name: Optional[str] = None):
        super().__init__(name or "ImmediateExecution")

    def execute(self, targets: List[PortfolioTarget],
                current_holdings: Dict[str, float],
                current_prices: Dict[str, float],
                portfolio_value: float) -> List[OrderTicket]:
        """Generate immediate market orders."""
        orders = []

        for target in targets:
            symbol = target.symbol
            current_qty = current_holdings.get(symbol, 0)
            price = current_prices.get(symbol, 0)

            if price <= 0:
                continue

            # Calculate target quantity from percentage
            if target.quantity >= -1.0 and target.quantity <= 1.0:
                # Percentage target
                target_value = portfolio_value * target.quantity
                target_qty = target_value / price
            else:
                # Absolute quantity target
                target_qty = target.quantity

            # Calculate order quantity
            order_qty = target_qty - current_qty

            if abs(order_qty) < 0.001:  # Skip tiny orders
                continue

            side = OrderSide.BUY if order_qty > 0 else OrderSide.SELL

            orders.append(OrderTicket(
                symbol=symbol,
                quantity=abs(order_qty),
                order_type=OrderType.MARKET,
                side=side,
                tag=target.tag or "ImmediateExecution",
            ))

        return orders


class VWAPExecutionModel(ExecutionModel):
    """
    VWAP Execution Model.

    Splits orders into smaller chunks and executes over time
    to achieve volume-weighted average price.

    Ported from LEAN's VolumeWeightedAveragePriceExecutionModel.cs
    """

    def __init__(self, max_order_size_percent: float = 0.01,
                 time_slices: int = 10,
                 name: Optional[str] = None):
        """
        Args:
            max_order_size_percent: Max order as percent of daily volume (1%)
            time_slices: Number of slices to break order into
        """
        super().__init__(name or f"VWAP({time_slices})")
        self._max_order_pct = max_order_size_percent
        self._time_slices = time_slices
        self._pending_orders: Dict[str, float] = {}  # symbol -> remaining qty
        self._slice_count: Dict[str, int] = {}

    def execute(self, targets: List[PortfolioTarget],
                current_holdings: Dict[str, float],
                current_prices: Dict[str, float],
                portfolio_value: float) -> List[OrderTicket]:
        """Generate VWAP slice orders."""
        orders = []

        for target in targets:
            symbol = target.symbol
            current_qty = current_holdings.get(symbol, 0)
            price = current_prices.get(symbol, 0)

            if price <= 0:
                continue

            # Calculate target quantity
            if -1.0 <= target.quantity <= 1.0:
                target_value = portfolio_value * target.quantity
                target_qty = target_value / price
            else:
                target_qty = target.quantity

            total_order_qty = target_qty - current_qty

            if abs(total_order_qty) < 0.001:
                continue

            # Initialize or update pending order
            if symbol not in self._pending_orders or \
               abs(self._pending_orders[symbol]) < 0.001:
                self._pending_orders[symbol] = total_order_qty
                self._slice_count[symbol] = 0

            # Calculate slice size
            remaining = self._pending_orders[symbol]
            slices_left = self._time_slices - self._slice_count.get(symbol, 0)

            if slices_left <= 0:
                slice_qty = remaining
            else:
                slice_qty = remaining / slices_left

            side = OrderSide.BUY if slice_qty > 0 else OrderSide.SELL

            orders.append(OrderTicket(
                symbol=symbol,
                quantity=abs(slice_qty),
                order_type=OrderType.MARKET,
                side=side,
                tag=f"VWAP slice {self._slice_count.get(symbol, 0) + 1}/{self._time_slices}",
            ))

            # Update tracking
            self._pending_orders[symbol] -= slice_qty
            self._slice_count[symbol] = self._slice_count.get(symbol, 0) + 1

        return orders

    def on_order_filled(self, symbol: str, quantity: float, price: float) -> None:
        """Track filled slices."""
        if symbol in self._pending_orders:
            # Order partially complete
            if abs(self._pending_orders[symbol]) < 0.001:
                del self._pending_orders[symbol]
                del self._slice_count[symbol]


class TWAPExecutionModel(ExecutionModel):
    """
    TWAP Execution Model.

    Time-Weighted Average Price - splits orders evenly over time.
    Similar to VWAP but uses equal time intervals instead of volume.

    Ported from LEAN's StandardDeviationExecutionModel approach
    """

    def __init__(self, interval_minutes: int = 5,
                 total_duration_minutes: int = 60,
                 name: Optional[str] = None):
        """
        Args:
            interval_minutes: Time between order slices
            total_duration_minutes: Total execution window
        """
        super().__init__(name or f"TWAP({interval_minutes}m)")
        self._interval = timedelta(minutes=interval_minutes)
        self._duration = timedelta(minutes=total_duration_minutes)
        self._num_slices = total_duration_minutes // interval_minutes

        self._pending_orders: Dict[str, float] = {}
        self._last_execution: Dict[str, datetime] = {}
        self._slices_sent: Dict[str, int] = {}

    def execute(self, targets: List[PortfolioTarget],
                current_holdings: Dict[str, float],
                current_prices: Dict[str, float],
                portfolio_value: float) -> List[OrderTicket]:
        """Generate TWAP slice orders."""
        orders = []
        now = datetime.now()

        for target in targets:
            symbol = target.symbol
            current_qty = current_holdings.get(symbol, 0)
            price = current_prices.get(symbol, 0)

            if price <= 0:
                continue

            # Calculate target
            if -1.0 <= target.quantity <= 1.0:
                target_value = portfolio_value * target.quantity
                target_qty = target_value / price
            else:
                target_qty = target.quantity

            total_order_qty = target_qty - current_qty

            if abs(total_order_qty) < 0.001:
                continue

            # Initialize new order
            if symbol not in self._pending_orders or \
               abs(self._pending_orders[symbol]) < 0.001:
                self._pending_orders[symbol] = total_order_qty
                self._slices_sent[symbol] = 0
                self._last_execution[symbol] = now - self._interval

            # Check if it's time for next slice
            last_exec = self._last_execution.get(symbol, now - self._interval)
            if now - last_exec < self._interval:
                continue

            # Calculate slice
            remaining = self._pending_orders[symbol]
            slices_left = self._num_slices - self._slices_sent.get(symbol, 0)

            if slices_left <= 1:
                slice_qty = remaining  # Last slice gets remainder
            else:
                slice_qty = remaining / slices_left

            side = OrderSide.BUY if slice_qty > 0 else OrderSide.SELL

            orders.append(OrderTicket(
                symbol=symbol,
                quantity=abs(slice_qty),
                order_type=OrderType.MARKET,
                side=side,
                tag=f"TWAP {self._slices_sent.get(symbol, 0) + 1}/{self._num_slices}",
            ))

            # Update tracking
            self._pending_orders[symbol] -= slice_qty
            self._slices_sent[symbol] = self._slices_sent.get(symbol, 0) + 1
            self._last_execution[symbol] = now

        return orders


class LimitOrderExecutionModel(ExecutionModel):
    """
    Limit Order Execution Model.

    Places limit orders at specified price levels to minimize slippage.
    Orders may not fill if price doesn't reach limit.
    """

    def __init__(self, spread_percent: float = 0.001,
                 time_in_force: TimeInForce = TimeInForce.DAY,
                 name: Optional[str] = None):
        """
        Args:
            spread_percent: How much below/above market to set limit (0.1%)
        """
        super().__init__(name or f"Limit({spread_percent*100:.2f}%)")
        self._spread_pct = spread_percent
        self._time_in_force = time_in_force

    def execute(self, targets: List[PortfolioTarget],
                current_holdings: Dict[str, float],
                current_prices: Dict[str, float],
                portfolio_value: float) -> List[OrderTicket]:
        """Generate limit orders."""
        orders = []

        for target in targets:
            symbol = target.symbol
            current_qty = current_holdings.get(symbol, 0)
            price = current_prices.get(symbol, 0)

            if price <= 0:
                continue

            # Calculate target
            if -1.0 <= target.quantity <= 1.0:
                target_value = portfolio_value * target.quantity
                target_qty = target_value / price
            else:
                target_qty = target.quantity

            order_qty = target_qty - current_qty

            if abs(order_qty) < 0.001:
                continue

            side = OrderSide.BUY if order_qty > 0 else OrderSide.SELL

            # Set limit price with spread
            if side == OrderSide.BUY:
                limit_price = price * (1 - self._spread_pct)  # Below market
            else:
                limit_price = price * (1 + self._spread_pct)  # Above market

            orders.append(OrderTicket(
                symbol=symbol,
                quantity=abs(order_qty),
                order_type=OrderType.LIMIT,
                side=side,
                limit_price=round(limit_price, 2),
                time_in_force=self._time_in_force,
                tag=target.tag or "LimitOrder",
            ))

        return orders


class SpreadExecutionModel(ExecutionModel):
    """
    Spread Execution Model.

    Uses limit orders that work the spread, starting at mid-price
    and adjusting over time if unfilled.
    """

    def __init__(self, max_spread_improvement: float = 0.5,
                 name: Optional[str] = None):
        """
        Args:
            max_spread_improvement: Max improvement to capture (0.5 = 50% of spread)
        """
        super().__init__(name or "SpreadExecution")
        self._max_improvement = max_spread_improvement
        self._unfilled_orders: Dict[str, OrderTicket] = {}

    def execute(self, targets: List[PortfolioTarget],
                current_holdings: Dict[str, float],
                current_prices: Dict[str, float],
                portfolio_value: float,
                bid_prices: Optional[Dict[str, float]] = None,
                ask_prices: Optional[Dict[str, float]] = None) -> List[OrderTicket]:
        """Generate spread-aware limit orders."""
        orders = []

        # Default to mid-price if no bid/ask
        bid_prices = bid_prices or current_prices
        ask_prices = ask_prices or current_prices

        for target in targets:
            symbol = target.symbol
            current_qty = current_holdings.get(symbol, 0)
            mid_price = current_prices.get(symbol, 0)
            bid = bid_prices.get(symbol, mid_price)
            ask = ask_prices.get(symbol, mid_price)

            if mid_price <= 0:
                continue

            # Calculate target
            if -1.0 <= target.quantity <= 1.0:
                target_value = portfolio_value * target.quantity
                target_qty = target_value / mid_price
            else:
                target_qty = target.quantity

            order_qty = target_qty - current_qty

            if abs(order_qty) < 0.001:
                continue

            side = OrderSide.BUY if order_qty > 0 else OrderSide.SELL
            spread = ask - bid

            # Calculate limit price to capture spread improvement
            if side == OrderSide.BUY:
                # Start at bid, move toward mid
                improvement = spread * self._max_improvement
                limit_price = bid + improvement
            else:
                # Start at ask, move toward mid
                improvement = spread * self._max_improvement
                limit_price = ask - improvement

            orders.append(OrderTicket(
                symbol=symbol,
                quantity=abs(order_qty),
                order_type=OrderType.LIMIT,
                side=side,
                limit_price=round(limit_price, 2),
                time_in_force=TimeInForce.IOC,  # Immediate or cancel
                tag="SpreadExecution",
            ))

        return orders


class StandardDeviationExecutionModel(ExecutionModel):
    """
    Standard Deviation Execution Model.

    Places limit orders based on recent price volatility.
    More aggressive limits in low volatility, wider in high volatility.

    Ported from LEAN's StandardDeviationExecutionModel.cs
    """

    def __init__(self, period: int = 20,
                 deviations: float = 2.0,
                 name: Optional[str] = None):
        """
        Args:
            period: Lookback period for std dev calculation
            deviations: Number of std devs for limit price
        """
        super().__init__(name or f"StdDevExecution({period},{deviations})")
        self._period = period
        self._deviations = deviations
        self._price_history: Dict[str, List[float]] = {}

    def add_price(self, symbol: str, price: float) -> None:
        """Add price to history for std dev calculation."""
        if symbol not in self._price_history:
            self._price_history[symbol] = []
        self._price_history[symbol].append(price)
        if len(self._price_history[symbol]) > self._period:
            self._price_history[symbol] = self._price_history[symbol][-self._period:]

    def execute(self, targets: List[PortfolioTarget],
                current_holdings: Dict[str, float],
                current_prices: Dict[str, float],
                portfolio_value: float) -> List[OrderTicket]:
        """Generate volatility-aware limit orders."""
        orders = []

        for target in targets:
            symbol = target.symbol
            current_qty = current_holdings.get(symbol, 0)
            price = current_prices.get(symbol, 0)

            if price <= 0:
                continue

            # Calculate target
            if -1.0 <= target.quantity <= 1.0:
                target_value = portfolio_value * target.quantity
                target_qty = target_value / price
            else:
                target_qty = target.quantity

            order_qty = target_qty - current_qty

            if abs(order_qty) < 0.001:
                continue

            side = OrderSide.BUY if order_qty > 0 else OrderSide.SELL

            # Calculate std dev if we have history
            std_dev = 0.0
            if symbol in self._price_history and len(self._price_history[symbol]) >= 5:
                prices = self._price_history[symbol]
                mean = sum(prices) / len(prices)
                variance = sum((p - mean) ** 2 for p in prices) / len(prices)
                std_dev = variance ** 0.5

            # Set limit based on volatility
            spread = std_dev * self._deviations

            if side == OrderSide.BUY:
                limit_price = price - spread  # Below market by std devs
            else:
                limit_price = price + spread  # Above market by std devs

            limit_price = max(0.01, limit_price)

            orders.append(OrderTicket(
                symbol=symbol,
                quantity=abs(order_qty),
                order_type=OrderType.LIMIT,
                side=side,
                limit_price=round(limit_price, 2),
                time_in_force=TimeInForce.DAY,
                tag=f"StdDev limit ({self._deviations} dev)",
            ))

        return orders


class NullExecutionModel(ExecutionModel):
    """
    Null Execution Model.

    Returns no orders. Useful for simulation/testing or when
    execution is handled externally.
    """

    def __init__(self):
        super().__init__("Null")

    def execute(self, targets: List[PortfolioTarget],
                current_holdings: Dict[str, float],
                current_prices: Dict[str, float],
                portfolio_value: float) -> List[OrderTicket]:
        """Return no orders."""
        return []
