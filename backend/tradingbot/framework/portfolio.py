"""
Portfolio Construction Models - Ported from QuantConnect LEAN.

Translates Insights from Alpha Models into Portfolio Targets (position sizing).

Original: https://github.com/QuantConnect/Lean/tree/master/Algorithm.Framework/Portfolio
License: Apache 2.0
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from typing import Dict, List, Optional, Any
from enum import Enum
import numpy as np

from .alpha import Insight, InsightDirection


@dataclass
class PortfolioTarget:
    """
    Represents a desired portfolio position.

    Generated by Portfolio Construction Models based on Insights.
    """
    symbol: str
    quantity: float  # Target quantity (can be fractional for sizing)
    tag: str = ""

    @property
    def is_percent(self) -> bool:
        """Whether this is a percentage target (0-1 range)."""
        return -1.0 <= self.quantity <= 1.0

    @classmethod
    def percent(cls, symbol: str, percent: float, tag: str = "") -> "PortfolioTarget":
        """Create a percentage-based target."""
        return cls(symbol=symbol, quantity=max(-1.0, min(1.0, percent)), tag=tag)

    def __repr__(self) -> str:
        return f"PortfolioTarget({self.symbol}, {self.quantity:.4f})"


class PortfolioConstructionModel(ABC):
    """
    Abstract base class for Portfolio Construction Models.

    Portfolio Construction Models take Insights and determine target
    portfolio weights or quantities for each security.
    """

    def __init__(self, name: Optional[str] = None):
        self._name = name or self.__class__.__name__

    @property
    def name(self) -> str:
        return self._name

    @abstractmethod
    def create_targets(self, insights: List[Insight],
                       portfolio_value: float,
                       current_holdings: Dict[str, float]) -> List[PortfolioTarget]:
        """
        Create portfolio targets from insights.

        Args:
            insights: List of active insights from Alpha Models
            portfolio_value: Current total portfolio value
            current_holdings: Current holdings {symbol: quantity}

        Returns:
            List of PortfolioTargets
        """
        pass

    def on_securities_changed(self, added: List[str], removed: List[str]) -> None:
        """Handle universe changes."""
        pass

    def __repr__(self) -> str:
        return f"{self._name}"


class EqualWeightingPortfolioModel(PortfolioConstructionModel):
    """
    Equal Weighting Portfolio Construction Model.

    Assigns equal weight to all securities with active insights.
    Position direction is determined by insight direction.

    Ported from LEAN's EqualWeightingPortfolioConstructionModel.cs
    """

    def __init__(self, rebalance_tolerance: float = 0.05,
                 name: Optional[str] = None):
        """
        Args:
            rebalance_tolerance: Minimum deviation to trigger rebalance (5%)
        """
        name = name or "EqualWeighting"
        super().__init__(name)
        self._rebalance_tolerance = rebalance_tolerance
        self._active_insights: Dict[str, Insight] = {}

    def create_targets(self, insights: List[Insight],
                       portfolio_value: float,
                       current_holdings: Dict[str, float]) -> List[PortfolioTarget]:
        """Create equally-weighted targets for active insights."""
        targets = []

        # Update active insights (newer insight replaces older)
        for insight in insights:
            if insight.is_active:
                self._active_insights[insight.symbol] = insight

        # Remove expired insights
        expired = [s for s, i in self._active_insights.items() if i.is_expired]
        for symbol in expired:
            del self._active_insights[symbol]
            # Add target to close position
            targets.append(PortfolioTarget.percent(symbol, 0.0))

        # Calculate equal weight
        active_count = len(self._active_insights)
        if active_count == 0:
            return targets

        weight = 1.0 / active_count

        for symbol, insight in self._active_insights.items():
            direction_weight = weight * insight.direction.value

            # Apply insight weight if specified
            if insight.weight != 1.0:
                direction_weight *= insight.weight

            targets.append(PortfolioTarget.percent(symbol, direction_weight))

        return targets


class InsightWeightingPortfolioModel(PortfolioConstructionModel):
    """
    Insight Weighting Portfolio Construction Model.

    Weights positions based on insight confidence and magnitude.
    Higher confidence/magnitude insights get larger allocations.
    """

    def __init__(self, use_confidence: bool = True,
                 use_magnitude: bool = True,
                 name: Optional[str] = None):
        name = name or "InsightWeighting"
        super().__init__(name)
        self._use_confidence = use_confidence
        self._use_magnitude = use_magnitude
        self._active_insights: Dict[str, Insight] = {}

    def create_targets(self, insights: List[Insight],
                       portfolio_value: float,
                       current_holdings: Dict[str, float]) -> List[PortfolioTarget]:
        """Create targets weighted by insight properties."""
        targets = []

        # Update active insights
        for insight in insights:
            if insight.is_active:
                self._active_insights[insight.symbol] = insight

        # Remove expired
        expired = [s for s, i in self._active_insights.items() if i.is_expired]
        for symbol in expired:
            del self._active_insights[symbol]
            targets.append(PortfolioTarget.percent(symbol, 0.0))

        if not self._active_insights:
            return targets

        # Calculate weights based on confidence/magnitude
        weights = {}
        for symbol, insight in self._active_insights.items():
            weight = 1.0

            if self._use_confidence and insight.confidence is not None:
                weight *= insight.confidence

            if self._use_magnitude and insight.magnitude is not None:
                weight *= min(abs(insight.magnitude), 1.0)

            weight *= insight.weight
            weights[symbol] = weight * insight.direction.value

        # Normalize weights to sum to 1 (absolute values)
        total_abs_weight = sum(abs(w) for w in weights.values())
        if total_abs_weight > 0:
            for symbol, weight in weights.items():
                normalized = weight / total_abs_weight
                targets.append(PortfolioTarget.percent(symbol, normalized))

        return targets


class MaximumSharpeRatioPortfolioModel(PortfolioConstructionModel):
    """
    Maximum Sharpe Ratio Portfolio Construction Model.

    Uses mean-variance optimization to find the portfolio with
    the maximum Sharpe ratio (risk-adjusted return).

    Ported from LEAN's MaximumSharpeRatioPortfolioConstructionModel.cs
    """

    def __init__(self, lookback_period: int = 252,
                 risk_free_rate: float = 0.02,
                 min_weight: float = 0.0,
                 max_weight: float = 1.0,
                 name: Optional[str] = None):
        name = name or f"MaxSharpe({lookback_period})"
        super().__init__(name)
        self._lookback = lookback_period
        self._risk_free_rate = risk_free_rate
        self._min_weight = min_weight
        self._max_weight = max_weight
        self._returns_history: Dict[str, List[float]] = {}

    def add_returns(self, symbol: str, daily_return: float) -> None:
        """Add historical return data for optimization."""
        if symbol not in self._returns_history:
            self._returns_history[symbol] = []
        self._returns_history[symbol].append(daily_return)
        # Keep only lookback period
        if len(self._returns_history[symbol]) > self._lookback:
            self._returns_history[symbol] = self._returns_history[symbol][-self._lookback:]

    def create_targets(self, insights: List[Insight],
                       portfolio_value: float,
                       current_holdings: Dict[str, float]) -> List[PortfolioTarget]:
        """Create targets using maximum Sharpe ratio optimization."""
        targets = []

        # Get symbols with active insights
        active_symbols = [i.symbol for i in insights if i.is_active]

        if not active_symbols:
            return targets

        # Check if we have enough history
        valid_symbols = [s for s in active_symbols
                        if s in self._returns_history
                        and len(self._returns_history[s]) >= 30]

        if len(valid_symbols) < 2:
            # Fall back to equal weighting
            weight = 1.0 / len(active_symbols) if active_symbols else 0
            for symbol in active_symbols:
                insight = next((i for i in insights if i.symbol == symbol), None)
                direction = insight.direction.value if insight else 1
                targets.append(PortfolioTarget.percent(symbol, weight * direction))
            return targets

        # Build returns matrix
        min_len = min(len(self._returns_history[s]) for s in valid_symbols)
        returns_matrix = np.array([
            self._returns_history[s][-min_len:] for s in valid_symbols
        ])

        # Calculate expected returns and covariance
        expected_returns = np.mean(returns_matrix, axis=1) * 252  # Annualize
        cov_matrix = np.cov(returns_matrix) * 252  # Annualize

        # Find maximum Sharpe ratio weights using analytical solution
        weights = self._optimize_sharpe(expected_returns, cov_matrix)

        # Apply direction from insights
        for i, symbol in enumerate(valid_symbols):
            insight = next((ins for ins in insights if ins.symbol == symbol), None)
            direction = insight.direction.value if insight else 1

            final_weight = weights[i] * direction
            final_weight = max(self._min_weight, min(self._max_weight, abs(final_weight)))
            final_weight *= np.sign(direction) if direction != 0 else 1

            targets.append(PortfolioTarget.percent(symbol, final_weight))

        return targets

    def _optimize_sharpe(self, expected_returns: np.ndarray,
                         cov_matrix: np.ndarray) -> np.ndarray:
        """Find weights that maximize Sharpe ratio."""
        n = len(expected_returns)

        # Handle degenerate cases
        if n == 0:
            return np.array([])
        if n == 1:
            return np.array([1.0])

        # Excess returns
        excess_returns = expected_returns - self._risk_free_rate

        try:
            # Analytical solution for max Sharpe
            inv_cov = np.linalg.inv(cov_matrix + np.eye(n) * 1e-6)
            weights = inv_cov @ excess_returns

            # Normalize to sum to 1
            total = np.sum(np.abs(weights))
            if total > 0:
                weights = weights / total
            else:
                weights = np.ones(n) / n
        except np.linalg.LinAlgError:
            # Fall back to equal weighting
            weights = np.ones(n) / n

        return weights


class MeanVariancePortfolioModel(PortfolioConstructionModel):
    """
    Mean-Variance Portfolio Construction Model.

    Minimizes portfolio variance for a target return,
    or maximizes return for a target risk level.
    """

    def __init__(self, target_return: Optional[float] = None,
                 target_volatility: Optional[float] = None,
                 lookback_period: int = 252,
                 name: Optional[str] = None):
        name = name or "MeanVariance"
        super().__init__(name)
        self._target_return = target_return
        self._target_volatility = target_volatility
        self._lookback = lookback_period
        self._returns_history: Dict[str, List[float]] = {}

    def add_returns(self, symbol: str, daily_return: float) -> None:
        """Add historical return data."""
        if symbol not in self._returns_history:
            self._returns_history[symbol] = []
        self._returns_history[symbol].append(daily_return)
        if len(self._returns_history[symbol]) > self._lookback:
            self._returns_history[symbol] = self._returns_history[symbol][-self._lookback:]

    def create_targets(self, insights: List[Insight],
                       portfolio_value: float,
                       current_holdings: Dict[str, float]) -> List[PortfolioTarget]:
        """Create mean-variance optimized targets."""
        targets = []
        active_symbols = [i.symbol for i in insights if i.is_active]

        if not active_symbols:
            return targets

        valid_symbols = [s for s in active_symbols
                        if s in self._returns_history
                        and len(self._returns_history[s]) >= 30]

        if len(valid_symbols) < 2:
            weight = 1.0 / len(active_symbols)
            for symbol in active_symbols:
                targets.append(PortfolioTarget.percent(symbol, weight))
            return targets

        # Build covariance matrix
        min_len = min(len(self._returns_history[s]) for s in valid_symbols)
        returns_matrix = np.array([
            self._returns_history[s][-min_len:] for s in valid_symbols
        ])

        cov_matrix = np.cov(returns_matrix) * 252

        # Minimum variance portfolio
        weights = self._min_variance_weights(cov_matrix)

        for i, symbol in enumerate(valid_symbols):
            insight = next((ins for ins in insights if ins.symbol == symbol), None)
            direction = insight.direction.value if insight else 1
            targets.append(PortfolioTarget.percent(symbol, weights[i] * direction))

        return targets

    def _min_variance_weights(self, cov_matrix: np.ndarray) -> np.ndarray:
        """Calculate minimum variance portfolio weights."""
        n = cov_matrix.shape[0]

        try:
            inv_cov = np.linalg.inv(cov_matrix + np.eye(n) * 1e-6)
            ones = np.ones(n)
            weights = inv_cov @ ones
            weights = weights / np.sum(weights)
        except np.linalg.LinAlgError:
            weights = np.ones(n) / n

        return weights


class RiskParityPortfolioModel(PortfolioConstructionModel):
    """
    Risk Parity Portfolio Construction Model.

    Allocates capital so each asset contributes equally to portfolio risk.
    This typically results in lower volatility portfolios.

    Ported from LEAN's RiskParityPortfolioConstructionModel.cs
    """

    def __init__(self, lookback_period: int = 252,
                 name: Optional[str] = None):
        name = name or f"RiskParity({lookback_period})"
        super().__init__(name)
        self._lookback = lookback_period
        self._returns_history: Dict[str, List[float]] = {}

    def add_returns(self, symbol: str, daily_return: float) -> None:
        """Add historical return data."""
        if symbol not in self._returns_history:
            self._returns_history[symbol] = []
        self._returns_history[symbol].append(daily_return)
        if len(self._returns_history[symbol]) > self._lookback:
            self._returns_history[symbol] = self._returns_history[symbol][-self._lookback:]

    def create_targets(self, insights: List[Insight],
                       portfolio_value: float,
                       current_holdings: Dict[str, float]) -> List[PortfolioTarget]:
        """Create risk parity targets."""
        targets = []
        active_symbols = [i.symbol for i in insights if i.is_active]

        if not active_symbols:
            return targets

        valid_symbols = [s for s in active_symbols
                        if s in self._returns_history
                        and len(self._returns_history[s]) >= 30]

        if len(valid_symbols) < 2:
            weight = 1.0 / len(active_symbols)
            for symbol in active_symbols:
                targets.append(PortfolioTarget.percent(symbol, weight))
            return targets

        # Calculate volatilities
        volatilities = []
        for symbol in valid_symbols:
            returns = np.array(self._returns_history[symbol][-self._lookback:])
            vol = np.std(returns) * np.sqrt(252)  # Annualized
            volatilities.append(max(vol, 0.001))  # Prevent division by zero

        # Inverse volatility weighting (simplified risk parity)
        inv_vols = [1.0 / v for v in volatilities]
        total_inv_vol = sum(inv_vols)
        weights = [iv / total_inv_vol for iv in inv_vols]

        for i, symbol in enumerate(valid_symbols):
            insight = next((ins for ins in insights if ins.symbol == symbol), None)
            direction = insight.direction.value if insight else 1
            targets.append(PortfolioTarget.percent(symbol, weights[i] * direction))

        return targets


class BlackLittermanPortfolioModel(PortfolioConstructionModel):
    """
    Black-Litterman Portfolio Construction Model.

    Combines market equilibrium with investor views (from Insights).
    Provides a more stable alternative to mean-variance optimization.
    """

    def __init__(self, tau: float = 0.05,
                 risk_aversion: float = 2.5,
                 lookback_period: int = 252,
                 name: Optional[str] = None):
        name = name or "BlackLitterman"
        super().__init__(name)
        self._tau = tau  # Scaling factor for uncertainty
        self._risk_aversion = risk_aversion
        self._lookback = lookback_period
        self._returns_history: Dict[str, List[float]] = {}
        self._market_caps: Dict[str, float] = {}

    def set_market_cap(self, symbol: str, market_cap: float) -> None:
        """Set market capitalization for a symbol."""
        self._market_caps[symbol] = market_cap

    def add_returns(self, symbol: str, daily_return: float) -> None:
        """Add historical return data."""
        if symbol not in self._returns_history:
            self._returns_history[symbol] = []
        self._returns_history[symbol].append(daily_return)
        if len(self._returns_history[symbol]) > self._lookback:
            self._returns_history[symbol] = self._returns_history[symbol][-self._lookback:]

    def create_targets(self, insights: List[Insight],
                       portfolio_value: float,
                       current_holdings: Dict[str, float]) -> List[PortfolioTarget]:
        """Create Black-Litterman optimized targets."""
        targets = []
        active_insights = [i for i in insights if i.is_active]
        active_symbols = [i.symbol for i in active_insights]

        if not active_symbols:
            return targets

        valid_symbols = [s for s in active_symbols
                        if s in self._returns_history
                        and len(self._returns_history[s]) >= 30]

        if len(valid_symbols) < 2:
            weight = 1.0 / len(active_symbols)
            for symbol in active_symbols:
                targets.append(PortfolioTarget.percent(symbol, weight))
            return targets

        n = len(valid_symbols)

        # Build covariance matrix
        min_len = min(len(self._returns_history[s]) for s in valid_symbols)
        returns_matrix = np.array([
            self._returns_history[s][-min_len:] for s in valid_symbols
        ])
        cov_matrix = np.cov(returns_matrix) * 252

        # Calculate market cap weights (equilibrium)
        market_caps = np.array([
            self._market_caps.get(s, 1e9) for s in valid_symbols
        ])
        market_weights = market_caps / np.sum(market_caps)

        # Implied equilibrium returns
        pi = self._risk_aversion * cov_matrix @ market_weights

        # Build views from insights
        views = []
        confidences = []
        for symbol in valid_symbols:
            insight = next((i for i in active_insights if i.symbol == symbol), None)
            if insight and insight.magnitude is not None:
                views.append(insight.magnitude * insight.direction.value)
                confidences.append(insight.confidence or 0.5)
            else:
                views.append(0)
                confidences.append(0.1)

        views = np.array(views)

        # View uncertainty matrix (diagonal)
        omega = np.diag([
            self._tau * cov_matrix[i, i] / max(c, 0.1)
            for i, c in enumerate(confidences)
        ])

        # Black-Litterman formula
        try:
            P = np.eye(n)  # Each view is about one asset
            inv_tau_cov = np.linalg.inv(self._tau * cov_matrix + 1e-6 * np.eye(n))
            inv_omega = np.linalg.inv(omega + 1e-6 * np.eye(n))

            posterior_cov = np.linalg.inv(inv_tau_cov + P.T @ inv_omega @ P)
            posterior_returns = posterior_cov @ (inv_tau_cov @ pi + P.T @ inv_omega @ views)

            # Optimal weights
            weights = np.linalg.inv(self._risk_aversion * cov_matrix) @ posterior_returns
            weights = weights / np.sum(np.abs(weights))
        except np.linalg.LinAlgError:
            weights = np.ones(n) / n

        for i, symbol in enumerate(valid_symbols):
            targets.append(PortfolioTarget.percent(symbol, weights[i]))

        return targets


class NullPortfolioModel(PortfolioConstructionModel):
    """
    Null Portfolio Construction Model.

    Returns empty targets. Useful when you want to manage
    positions manually or through a different mechanism.
    """

    def __init__(self):
        super().__init__("Null")

    def create_targets(self, insights: List[Insight],
                       portfolio_value: float,
                       current_holdings: Dict[str, float]) -> List[PortfolioTarget]:
        """Return no targets."""
        return []
